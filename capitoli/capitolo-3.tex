% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Descrizione dello stage}
\label{cap:descrizione-stage}
%**************************************************************

\intro{In questo capitolo si introduce il contesto in cui lo stage viene svolto e viene fornita una panoramica del progetto. Successivamente si descrivono le principali tecnologie utilizzate per raggiungere gli obiettivi prefissati. Inoltre sono analizzati i vincoli, gli obiettivi e la pianificazione dello stage}\\

%**************************************************************
\section{Introduzione al progetto}
L’obiettivo di SyncLab è sviluppare un’applicazione per il contact tracing.
Il software deve poter registrare i contatti tra le persone sfruttando il bluetooth LE. Le informazioni da raccogliere riguardano il tempo e la distanza di contatto con gli altri dispositivi, assicurando il rispetto della privacy. In questo modo quando una persona risulta infetta è possibile notificarlo a tutti i suoi contatti.\\

L’azienda ha incaricato diversi stagisti per sviluppare un’applicazione mobile e una web application che gestiscano il contact tracing, la prima lato utente generico, la seconda lato utente sanitario. 
Lo scopo della applicazione mobile è quello di registrare i contatti, mentre lo scopo della webapp è fornire l’autorità al personale medico di segnalare una persona risultata positiva a un tampone, sempre dietro conferma del malato.\\

Questo è il quadro generico dove si inserisce il mio percorso di stage.
Infatti mi è stato proposto di studiare e implementare uno smart contract per registrare i contatti nella piattaforma ethereum. 
Lo scopo del mio percorso si può sintetizzare nei seguenti punti:
\begin{itemize}
	\item{Studio tecnologico delle blockchain (in particolare ethereum);}
	\item{Analisi e sviluppo di uno smart contract per il contact tracing in linguaggio solidity;}
	\item{Studio e utilizzo dello smart contract in ambiente mobile (Android).}
\end{itemize}

%**************************************************************

\section{Studio tecnologico}
Lo studio richiesto per lo svolgimento dello stage parte dalla tecnologia blockchain in tutti i suoi aspetti, per poi passare nello studio specifico di ethereum, solidity e tutti gli strumenti di supporto per lo sviluppo e il testing di smart contract. Infine è necessario uno studio di ethereum applicato ad un ambiente mobile.

\subsection{Blockchain}
Una blockchain è un registro pubblico, distribuito e decentralizzato. Può essere utilie immaginarlo come un grande database distribuito su molti nodi, in continua espansione. Il registro è strutturato come una catena di blocchi contenenti le transazioni. Le principali caratteristiche di una blockchain sono l’immutabilità, la trasparenza, la tracciabilità delle transazioni e la sicurezza.

\subsubsection{Permissionless e permissioned}
Le blockchain si dividono in due categorie: blockchain permissionless (o pubbliche) e blockchain permissioned (o private). Le prime permettono l’accesso a qualsiasi utente che decida di connettersi e partecipare, generando nuove transazioni, effettuando il compito di miner o semplicemente leggendo il registro delle transazioni memorizzate. Bitcoin ed ethereum sono esempi di blockchain pubbliche.
Le seconde invece permettono l’accesso solo ad utenti autorizzati ed autenticati poiché la Blockchain in questione opera esclusivamente entro i limiti di una comunità ben definita dove tutti i partecipanti sono noti. Solitamente a capo di questi sistemi si trovano istituti finanziari o agenzie governative che definiscono chi possa accedere o meno alla rete. Questo vuol dire che tutti i miner sono considerati fidati.

\subsubsection{Nodi, transazioni, blocchi, ledger}
Per comprendere al meglio il funzionamento di una blockchain è utile spiegare i componenti basilari da cui è formata:
\begin{itemize}
	\item{Nodi:} sono i partecipanti alla blockchain. Qualsiasi dispositivo che si connette alla blockchain è considerato un nodo, ma ne esistono di diversi tipi in base al ruolo che hanno nella rete.
	\item{Transazione:}  è costituita dai dati che rappresentano i valori oggetto di scambio e che necessitano di essere verificati, approvati e poi archiviati.
	\item{Blocco:} è rappresentato dal raggruppamento di un insieme di transazioni che sono unite per essere verificate, approvate e poi archiviate dai partecipanti alla blockchain. 
	\item{Ledger:}  il registro pubblico nel quale vengono annotate con la massima trasparenza e in modo immutabile tutte le transazioni effettuate in modo ordinato e sequenziale. Il Ledger è costituito dall’insieme dei blocchi che sono tra loro incatenati tramite una funzione di crittografia e grazie all’uso di hash.
\end{itemize}

\subsubsection{Generali bizantini}
La blockchain nasce per eliminare il bisogno di una terza parte per validare una transazione. Per farlo è necessario che tutti i nodi siano concordi sulla validità e l’ordine delle transazioni. È dunque fondamentale introdurre un algoritmo di consenso per validare i blocchi e quindi le transazioni. Per capire a pieno questo concetto è ragionevole introdurre il problema matematico dei generali bizantini.\\\\
Diversi generali, durante un assedio, sono sul punto di attaccare una città nemica. Essi sono dislocati in diverse aree strategiche e possono comunicare solo mediante messaggeri al fine di coordinare l’attacco decisivo.
Il problema è che tutti sanno che tra di loro si trovano uno o più traditori. 
Come può ciascun luogotenente avere la certezza che una volta ricevuto l’ordine di attacco, questo sia stato inviato anche agli altri? Dunque come può essere certo di non essere l’unico ad averlo ricevuto in quella forma e dunque che tutti gli altri luogotenenti siano nella condizione di trasmettere e condividere lo stesso ordine?
Come è possibile garantire ai generali e a tutti i luogotenenti che nessuno cerchi di minare il piano?
Lo scopo del problema è far sì che ai luogotenenti onesti arrivi il piano d’attacco corretto, senza che i traditori possano compromettere l’operazione facendo arrivare loro le informazioni sbagliate.
In una blockchain, la soluzione è quella di non avere più un generale che comanda sugli altri. Dunque non c’è più un centro che prevale gerarchicamente. Ma si assegna la stessa gerarchia a tutti i partecipanti. Tutti i generali e tutti i luogotenenti, ovvero tutti i nodi, che partecipano a questo modello, concordano ogni singolo messaggio trasmesso tra i nodi, lo vedono e lo condividono. Tutti devono concordare ogni messaggio che viene trasmesso nella rete. Tutti vedono qualsiasi messaggio e qualsiasi modifica. Di conseguenza la blockchain risulta immutabile, immodificabile incorruttibile.


\subsubsection{Algoritmi di consenso}
L’obiettivo di un algoritmo di consenso è ottenere la validazione delle transazioni in una blockchain. Questo si traduce in un comune accordo sullo stato della blockchain tra i nodi partecipanti. Ogni transazione deve essere registrata nel ledger e l’algoritmo di consenso assicura che non ci siano state transazioni maligne o corrotte.
Esistono diversi tipi di algoritmi, ma mi limiterò a spiegare i due principali, su cui si fonda la quasi totalità delle blockchain.\\

L’algoritmo proof of work si basa sulla generazione di blocchi attraverso complessi problemi matematici, la cui risoluzione richiede un grande sforzo computazionale e un grosso dispendio di tempo ed energia.
Questa metodologia comporta la ricerca di un valore che, una volta sottoposto ad una funzione hash, restituisca un ulteriore hash che inizia con un certo numero di bit a zero. Il lavoro medio richiesto è esponenzialmente proporzionale al numero di bit a zero richiesti e può essere verificato immediatamente. Si adotta un valore hash con un numero selezionabile di bit a zero al fine di non semplificare la sua generazione, dal momento che l’avanzamento tecnologico offre calcolatori di potenza crescente. Il nodo che riesce a trovare il valore hash corretto prima degli altri crea il blocco: esso verrà aggiunto in coda alla blockchain e riceverà
un compenso sotto forma di valuta virtuale, chiamata cripto-valuta. L’algoritmo Proof-of-Work non risolve in modo ottimo la Byzantine Fault Tolerance ma offre al contempo una delle implementazioni più sicure ed affidabili per le reti blockchain.

Il proof of stake cambia paradigma: i blocchi vengono validati da chi possiede più token nella blockchain. Ogni account ha una possibilità proporzionale al proprio saldo di generare un blocco valido. Rispetto al proof of work, questo approccio presenta molti vantaggi. POW, infatti, richiede un'enorme quantità di tempo ed energia, che comporta un limitato numero di transazioni al secondo e un costo elevato da parte dell’utente per ottenere la validazione della propria transazione. Con POS si ottiene maggiore scalabilità e minore costo di tasse.
Inoltre la struttura della blockchain la rende più sicura. Consideriamo l’attacco del 51 percento: se un miner detiene la maggioranza dello stake non ha nel suo interesse un attacco alla rete perché se il valore della criptovaluta crolla, crollerebbero anche tutti i suoi averi. Per questo i maggiori proprietari di tokens avranno nel loro interesse il mantenimento di una rete sicura.

Il proof of work è stato il primo algoritmo utilizzato nelle blockchain ed è tutt’ora il più diffuso. Negli ultimi anni però stanno nascendo molte blockchain che si basano su proof of stake e persino ethereum entro la fine del 2020 inizierà il passaggio al POS, che si dovrebbe completare nel 2022.

\subsection{Ethereum}
Ethereum è una piattaforma decentralizzata creata nel 2015 da Vitalik Buterik e che ha riscosso fin da subito grande successo. In ethereum vengono eseguiti programmi chiamati smart contracts. Anche Bitcoin ha un linguaggio che gli permette di la creazione di smart contract, ma a differenza della famosa blockchain, Ethereum permette la scrittura di contratti turing-completi. Negli smart contracts è possibile programmare come in qualsiasi altro linguaggio di programmazione, seppur con delle differenze di cui discuteremo più avanti.

\subsubsection{Account, transazioni e gas}
\paragraph{Account}
In Ethereum ogni partecipante alla blockchain possiede un account con cui interagire nella rete. Anche gli smart contracts hanno un account, fondamentale per raggiungerli e interagire con loro. Gli account hanno un \textit{balance} in Ether, la cryptovaluta di Ethereum, che può essere modificato da transazioni inviate o ricevute.
\paragraph{Transazioni}
Una transazione è composta dall'account target, l'account sender, il valore trasferito in Ether, campi dati opzionali, il limite di gas che la transazione può consumare e il prezzo del gas.
\paragraph{Gas}
Ogni transazione consuma un certo numero di gas, che rappresenta il carburante della blockchain. Ogni operazione negli smart contract ha un costo in gas che deve essere pagato come tassa per far sì che venga eseguita in Ethereum. 

\subsubsection{Solidity}
Solidity è un linguaggio tipato che permette di scrivere smart contracts. I contracts a prima vista ricordano molto le classi nella programmazione orientata a ogggetti, ma in solidity bisogna prestare particolare attenzione alla sicurezza, in quanto gli smart contracts gestiscono soldi e transazioni. Se sono presenti bug o falle di sicurezza le conseguenze potrebbero essere gravi. Inoltre è sempre opportuno tenere a mente che le operazioni non sono gratuite, ma vengono pagate con delle tasse in base al tipo di operazione richiesta. L'efficienza quindi, è cruciale nel definire smart contracts e non sempre le best practices in solidity corrispondono alla soluzione che può sembrare migliore in un altro linguaggio di programmazione.

\subsubsection{Truffle}
Truffle è una suite di supporto per la programmazione in solidity che ha l'obiettivo di rendere la vita dello sviluppatore più semplice. Fornisce un ambiente di sviluppo e un framework per testare i contratti usando una EVM (Ethereum Virtual Machine). 
\subsubsection{Web3js e web3j}
Tra gli obiettivi del mio stage c'è l'integrazione dello smart contract sviluppato con un ambiente mobile e una web application. Web3.js e web3j servono proprio per raggiungere questo scopo. Sono librerie, la prima per JavaScript e la seconda per Java, che forniscono il supporto necessario a interagire con il contratto.

%**************************************************************

\section{Analisi dei rischi}

Durante la fase di analisi iniziale sono stati individuati alcuni possibili rischi a cui si potrà andare incontro.
Si è quindi proceduto a elaborare delle possibili soluzioni per far fronte a tali rischi.\\

\begin{risk}{Difficoltà nell'effettuare la maggior parte dello stage in remoto}
    \riskdescription{A causa dell'emergenza sanitaria causata dal COVID-19, gran parte dello stage verrà effettuato da remoto}
    \risksolution{Pianificazione del lavoro dettagliata; frequenti aggiornamenti con tutor aziendale; utilizzo di strumenti di supporto}
\end{risk}
\begin{risk}{Scarsa conoscenza delle tecnologie previste per lo svolgimento dello stage}
    \riskdescription{Le blockchain, ethereum e lo sviluppo di smart contracts rappresentano un campo non affrontato durante il percorso di studi e poco conosciuto dal sottoscritto}
    \risksolution{Dedicare molto tempo allo studio approfondito di tutte le tecnologie in gioco per essere preparato a sufficienza al momento dello sviluppo}
\end{risk}
\begin{risk}{Difficoltà nell'integrazione di ethereum con l'ambiente mobile}
    \riskdescription{Il tutor aziendale mi ha avvisato preventivamente della sua scarsa conoscenza in questo ambito e delle possibilti difficoltà che potrebbero emergere}
    \risksolution{In fase di studio tecnologico, dedicare diverse ore ad approfondire questo aspetto}
\end{risk}
\begin{risk}{Tempo limitato per l'integrazione finale con il prodotto sviluppato dall'azienda}
    \riskdescription{Come riportato nel primo rischio, la maggior parte dello stage sarà effettuato da remoto. Il tempo a disposizione con gli altri sviluppatori sarà poco e deve essere sufficiente per portare a termine l'integrazione della blockchain nel progetto}
    \risksolution{Otiimizzare il tempo con gli altri sviluppatori in azienda e se necessario comunicare con loro e organizzare call durante il lavoro svolto da casa}
\end{risk}

%**************************************************************
\section{Vincoli e obiettivi}

\subsection{Vincoli temporali}
Lo stage si svolge in un periodo di 8 settimane lavorative per 8 ore al giorno. Visto il contesto lavorativo da remoto mi è stato richiesto di compilare quotidianamento un registro delle attività che consentisse al tutor aziendale di verificare il mio lavoro. Verso la fine dello stage mi è stato consentito di lavorare alcuni giorni in azienda, dalle 9:00 alle 18:00. A prescindere dalla modalità di lavoro ho avuto delle scadenze settimanali da rispettare in base alla pianificazione. 
Infatti, il piano di lavoro presenta un calendario delle attività diviso per settimane che mi ha consentito di tenere sotto controllo lo stato di avanzamento del mio stage.

\subsection{Vincoli metodologici}
Per favorire il lavoro da remoto, il tutor aziendale mi ha fornito un piano delle attività presente su trello. Inoltre ogni giorno ho registrato le mie attività in un documento condiviso con il tutor e quasi quotidianamente sono state effettuate call per essere in costante aggiornamento.


\subsection{Vincoli tecnologici}
I vincoli tecnologici che ho dovuto rigorosamente rispettare sono stati:
\begin{itemize}
	\item{Ethereum e solidity per lo sviluppo dello smart contract}
	\item{Android per l'integrazione del contract in ambiente mobile}
	\item{Gitlab per la condivisione del mio lavoro}
\end{itemize}
Per il resto mi è stata concessa parecchia libertà riguardo agli strumenti di sviluppo e l'uso di tecnologie. Questo ha avuto dei pro e dei contro. Inizialmente ho dovuro dedicare parecchio tempo allo studio ed è stato difficile capire quali fossero le scelte migliori. A posteriori è stato molto utile e formativo, anche se alcune cose non sono state utilizzate nell'implementazione finale.
\subsection{Obiettivi}
Si prevede lo svolgimento dei seguenti obiettivi:
\renewcommand{\arraystretch}{3}
\begin{center}
	\begin{longtable}{| c | p{30em} |}
		\caption{Tabella degli obiettivi obbligatori}
		\label{tab:obiettivi-obbligatori}\\
		\hline
		\textbf{Obiettivo} & \centering\textbf{Descrizione}\\
		\endfirsthead
		\hline
		\textbf{Obiettivo} & \centering\textbf{Descrizione}\\
		\endhead
		\endfoot
		
		\hline
		O01    & Acquisizione competenze sulle tecnologie Blockchain, in particolare Ethereum  \\
		\hline
		O02    & Capacità di progettazione e analisi di smart contract \\
		\hline
		O03    & Capacità di raggiungere gli obiettivi richiesti in autonomia, seguendo il programma preventivato) \\
		\hline
		O04    & Portare a termine l'implementazione di almeno l'80\% degli sviluppi previsti \\
		\hline
	\end{longtable}
\end{center}

\begin{center}
	\begin{longtable}{| c | p{30em} |}
		\caption{Tabella degli obiettivi desiderabili}
		\label{tab:obiettivi-desiderabili}\\
		\hline
		\textbf{Obiettivo} & \centering\textbf{Descrizione}\\
		\endfirsthead
		\hline
		\textbf{Obiettivo} & \centering\textbf{Descrizione}\\
		\endhead
		\endfoot
		
		\hline
		D01    & Portare a termine il lavoro di studio della portabilità di Ethereum su dispositivi mobili \\
		\hline
		D02    & Portare a termine l’implementazione completa degli sviluppi previsti \\
		\hline
	\end{longtable}
\end{center}
	
\begin{center}
	\begin{longtable}{| c | p{30em} |}
		\caption{Tabella degli obiettivi facoltativi}
		\label{tab:obiettivi-facoltativi}\\
		\hline
		\textbf{Obiettivo} & \centering\textbf{Descrizione}\\
		\endfirsthead
		\hline
		\textbf{Obiettivo} & \centering\textbf{Descrizione}\\
		\endhead
		\endfoot
		
		\hline
		F01    & Completare l'installazione di un peer su un dispositivo mobile Android \\
		\hline
	\end{longtable}
\end{center}


%**************************************************************
\section{Pianificazione}
\begin{itemize}
        \item \textbf{Prima Settimana (40 ore)}
        \begin{itemize}
            \item Incontro con persone coinvolte nel progetto per discutere i requisiti e le richieste
            relativamente al sistema da sviluppare;
            \item Studio delle diverse tipologie di catene Block Chain (permissioned/unpermissioned/public/private); 
            \item Studio del funzionamento delle blockchain (diverse tipologie del proof).
        \end{itemize}
        \item \textbf{Seconda Settimana (40 ore)} 
        \begin{itemize}
            \item Studio di Ethereum, installazione peer e configurazione;
	    \item Ripasso Javascript;	
	    \item Studio linguaggio Solidity.
        \end{itemize}
        \item \textbf{Terza Settimana (40 ore)} 
        \begin{itemize}
            \item Studio linguaggio Solidity.
        \end{itemize}
        \item \textbf{Quarta Settimana (40 ore)} 
        \begin{itemize}
            \item Analisi caso d'uso: creazione smart contract per inserire in catena informazioni sul tracing delle persone;
	    \item Implementazione e testing del codice di smart contract per l'inserimento in catena delle informazioni raccolte sul tracing.
        \end{itemize}
        \item \textbf{Quinta Settimana (40 ore)} 
        \begin{itemize}
            \item Analisi Caso d'uso: creazione smart contract per recuperare da catena le informazioni sul tracing delle persone;
	    \item Implementazione e testing del codice di smart contract per il recupero delle informazioni raccolte sul tracing.
        \end{itemize}
        \item \textbf{Sesta Settimana (40 ore)} 
        \begin{itemize}
            \item Studio Installazione peer Ethereum in ambienti mobile.
        \end{itemize}
        \item \textbf{Settima Settimana (40 ore)} 
        \begin{itemize}
            \item Studio e prototipo di installazione del peer Ethereum in ambienti mobile.
        \end{itemize}
        \item \textbf{Ottava Settimana (40 ore)} 
        \begin{itemize}
            \item Installazioni finali e test;
	    \item Stesura tesina.
        \end{itemize}
    \end{itemize}